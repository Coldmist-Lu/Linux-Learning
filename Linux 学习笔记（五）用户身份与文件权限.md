# Linux 学习笔记（五）用户身份与文件权限

* 本笔记基于 刘遄 的《Linux 就该这么学》一书。
* 本章的先介绍了 UID 以及处理用户身份和用户信息的指令，然后介绍了文件类型和权限的概念与表示，接着介绍了 SUID、SGID、SBIT 三种特殊权限，然后介绍了隐藏权限以及用于单个文件修改的访问控制列表 ACL，最后介绍了用户切换和权限切换有关的 su 命令和 sudo 服务。



## 用户身份与能力

* Linux 的设计初衷是满足多个用户同时工作的需求，因此 Linux 必须具备很好的安全性。
* root 是管理员，也是存在于所有类 UNIX 系统中的超级用户。它拥有最高的系统所有权，能管理系统所有功能，如添加/删除用户、启动/关闭服务进程、开启/禁用硬件设备等。
* 但 root 管理员的工作不受到系统的限制，因此执行了错误的命令可能直接毁掉整个系统。
* 这里我们依然希望直接以管理员身份进行学习更好，因为可以刚好地知道错误。



### 用户身份——UID

* 错误的结论：管理员就是 root。
* 管理员之所以是 root，并不是因为名字是 root，而是用户的身份号码（User IDentification，UID）的数值为 0。
* 用户身份有以下这些：
  * UID 为 0：系统的管理员用户。
  * UID 为 1~999：系统用户，Linux 系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。
  * UID 为 1000 以上：普通用户，由管理员创建的用于日常工作的用户。
* 需要注意，UID 是不能冲突的，且即使有闲置号码，管理员创建的普通用户的 UID 也默认从 1000 开始。

#### 用户组

* 为了方便管理，Linux 还提供了用户组的概念。通过使用用户组号码（Group IDentification，GID），可把多个用户加入到同一组中，从而方便为组中的用户统一规划权限或指定任务。
  * 如公司有多个部门，每个部门有很多员工。则会指定让某个部门的员工只能访问这个部门的资源。
* 在创建用户时，Linux 系统将自动创建与其同名的基本用户组，而基本用户组只有该用户一个人。如果该用户之后被纳入其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组。



### useradd 命令

* useradd 命令用于创建新的用户。

#### 格式与用法

* useradd [选项] 用户名
* 创建用户时，默认的用户家目录会被存放在 /home 目录中，默认的 Shell 解释器为 /bin/bash，而且默认会创建一个与该用户同名的基本用户组。

#### 参数

* 可以通过参数来修改设置：

| 参数 | 作用                                      |
| ---- | ----------------------------------------- |
| -d   | 指定用户的家目录（默认为 /home/username） |
| -e   | 账户的到期时间，格式为 YYYY-MM-DD         |
| -u   | 指定该用户的默认 UID                      |
| -g   | 指定一个初始的基本用户组（必须已存在）    |
| -G   | 指定一个或多个扩展用户组                  |
| -N   | 不创建与用户同名的基本用户组              |
| -s   | 指定该用户的默认 Shell 解释器             |

#### 例子

* 下例创建一个普通用户并指定家目录的路径、用户的 UID 以及 Shell 解释器。
  * 请注意，/sbin/nologin 是一种终端解释器，与 Bash 解释器有天壤之别。一旦将用户的解释器设置为 nologin，则该用户不能登录到系统中。

```shell
useradd -d /home/linux -u 8888 -s /sbin/nologin linuxprobe
id linuxprobe
```

![1](Linux_5_pic/1.png)



### groupadd 命令

* groupadd 命令用于创建用户组。

#### 格式

* groupadd [选项] 群组名

#### 用法

* 工作中常常把几个用户加入到同一个组里面，这样可以针对一类用户统一安排权限。
* 下面是一个创建 ronny 用户组的例子：

```shell
groupadd ronny
```



### usermod 命令

* usermod 命令用于修改用户属性。

#### 格式与用法

* usermod [选项] 用户名
* 由于在系统中创建用户也是修改配置文件的过程，信息保存在 /etc/passwd 文件中，可直接用文本编辑器来修改用户参数数目，
* 也可以用 usermod 命令也可以修改用户信息，诸如用户的 UID、基本/扩展用户组、默认终端等。

#### 参数

* usermod 命令的参数及作用：

| 参数  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| -c    | 填写用户账户的备注信息                                       |
| -d -m | 参数 -m 与参数 -d 连用，可重新指定用户的家目录并自动把旧的数据转移过去 |
| -e    | 账户的到期时间，格式为 YYYY-MM-DD                            |
| -g    | 变更所属用户组                                               |
| -G    | 变更扩展用户组                                               |
| -L    | 锁定用户禁止其登录系统                                       |
| -U    | 解锁用户，允许其登录系统                                     |
| -s    | 变更默认终端                                                 |
| -u    | 修改用户的 UID                                               |

#### 例子

* 查看账户 linuxprobe 的默认信息：

```shell
id linuxprobe
```

* 将用户 linuxprobe 加入到 root 用户组中，这样扩展组列表中会出现 root 用户组：

```shell
usermod -G root linuxprobe
id linuxprobe
```

![2](Linux_5_pic/2.png)

* 下面用 -u 参数修改 linuxprobe 的 UID 号码值。
  * 还可以用 -g 参数修改用户的基本组 ID，用 -G 参数修改用户扩展组 ID。

```shell
usermod -u 8888 linuxprobe
id linuxprobe
```

![3](Linux_5_pic/3.png)



### passwd 命令

* passwd 命令用于修改用户密码、过期时间、认证信息等。

#### 格式与用法

* passwd [选项] [用户名]
* **普通用户**只能使用 passwd 命令修改自身的系统密码，而 root 管理员则**有权限修改其他所有人的密码**。更酷的是，root 管理员在Linux系统中修改自己或他人的密码时**不需要验证旧密码**，这一点特别方便。
* 既然 root 管理员可以修改其他用户的密码，就表示完全拥有该用户的管理权限。

#### 参数

* passwd 命令的参数及作用如下：

| 参数    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| -l      | 锁定用户，禁止其登录                                         |
| -u      | 解除锁定，允许用户登录                                       |
| --stdin | 允许通过标准输入修改用户密码，如 echo "NewPassWord" \| passwd --stdin Username |
| -d      | 使该用户可用空密码登录系统                                   |
| -e      | 强制用户在下次登录时修改密码                                 |
| -S      | 显示用户的密码是否被锁定，以及密码所采用的加密算法名称       |

#### 例子

* 下面演示如何修改用户自己的密码，以及如何修改其他人的密码（需要 root 权限）：

```shell
passwd # 修改root密码
# 输入密码值
# 再次输入确认
passwd linuxprobe
# 输入密码值
# 再次输入确认
```

![4](Linux_5_pic/4.png)

* 如果某用户长期不登录，可以使用 passwd 命令禁止用户登录系统，而不是删除。

```shell
passwd -l linuxprobe
passwd -S linuxprobe
passwd -u linuxprobe
passwd -S linuxprobe
```

![5](Linux_5_pic/5.png)



### userdel 命令

* userdel 命令用于删除用户。

#### 格式与用法

* userdel [选项] 用户名
* 通过userdel命令删除该用户的所有信息。在执行删除操作时，该用户的**家目录默认会保留**下来，此时可以使用 -r 参数将其删除。

#### 参数

* userdel 命令参数如下所示：

| 参数 | 作用                     |
| ---- | ------------------------ |
| -f   | 强制删除用户             |
| -r   | 同时删除用户及用户家目录 |

#### 例子

* 使用 userdel 命令将 linuxprobe 用户删除：

```shell
id linuxprobe
userdel -r linuxprobe
id linuxprobe
```

![6](Linux_5_pic/6.png)





## 文件权限与归属

### 文件类型与权限简介

#### 文件类型

* 尽管在 Linux 系统中一切都是文件，但是每个文件的类型不尽相同：
  * 因此 Linux 系统使用了不同的字符来加以区分，常见的字符如下所示。

| 字符 | 文件类型     |
| ---- | ------------ |
| -    | 普通文件     |
| d    | 目录文件     |
| l    | 链接文件     |
| b    | 块设备文件   |
| c    | 字符设备文件 |
| p    | 管道文件     |

#### 文件权限

* 在 Linux 系统中，每个文件都有所属的所有者和所有组，并且规定了文件的所有者、所有组以及其他人对文件所拥有的**可读**（r）、**可写**（w）、**可执行**（x）等权限。
* 对一般文件来说：
  * “可读” 表示能够读取文件的实际内容；
  * “可写” 表示能够编辑、新增、修改、删除文件的实际内容；
  * “可执行” 表示能够运行一个脚本程序。
* 重点：而对于目录文件来说：
  * “可读” 表示能够读取目录内的文件列表；
  * “可写” 表示能够在目录内新增、删除、重命名文件；
  * “可执行” 则表示能够进入该目录。



### 文件权限的表示

* 文件的读、写、执行权限可以简写为 rwx，亦可分别用数字 421 表示。
* 文件**所有者**，**所属组**及**其他用户**权限之间**无关联**。

#### 权限表示法

* 文件的权限表示分三个部分的权限，**从前往后**分别是：文件所有者、文件所属组、其他用户。
* 文件权限的数字法表示基于字符表示（rwx）的权限计算而来，其目的是简化权限的表示。
* 例如，若某个文件的权限为 **7** 则代表可读、可写、可执行（4+2+1）。
* 又例如，现在有这样一个文件，其所有者拥有**可读、可写、可执行**的权限，其文件所属组拥有**可读、可写**的权限；而且其他人只有**可读**的权限。那么，这个文件的权限就是 **rwxrw-r--**，数字法表示即为 **764**。由于这三者之间没有互通关系，所以不能写成 17。

#### 分析文件信息

* 下面分析下图所示的文件信息：

```shell
ls -l initial-setup-ks.cfg
```

![7](Linux_5_pic/7.png)

下面对文件显示的信息作出分析：

* -rw-r--r-- ：开头的 "-" 号表示文件类型为普通文件，后面是访问权限（对应数字是644）。
* 1：文件数。
* root：所有者（属主）。
* root：所属组（输组）。
* 1094：占用的磁盘大小。
* Jul 15 17:31 ：修改时间。
* initial-setup-ks.cfg ：文件名称。





## 文件的特殊权限

* 实际生产过程中，单纯设置 rwx 权限无法满足对安全和灵活性的需求，因此便有了 SUID、SGID 和 SBIT 三种特殊权限位。
* 这些特殊权限与一般权限同时使用，以弥补一般权限不能实现的功能。

### SUID

* SUID 是一种对二进制程序设置的特殊权限，可让二进制程序的执行者临时拥有属主的权限。
  * （仅对拥有执行权限的二进制程序有效）。
* 例如，所有用户都可以执行 passwd 命令来修改自己的用户密码，而用户密码保存在 /etc/shadow 文件中，但该文件的默认权限是 000，那么除了 root 管理员以外，所有用户都没有查看或编辑该文件的权限。但如果使用 passwd 命令时如果加上 SUID 特殊权限位，就可以让普通用户临时获得程序所有者的身份。

#### 特征

* SUID 权限的**直接特征**是权限表示法中**第一部分**（所有者的权限）的**最后一位**变成 **s** 或 **S**。
* 下面说明什么样的情况属于加了 SUID 权限：
* 查看属性时，所有者的权限由 rwx 变成了 rws，这就意味着文件被赋予了 SUID 权限；
* 查看属性时，如果原本的权限是 rw- ，会编程 rwS，意味着文件被赋予了 SUID 权限。

#### 例子

```shell
ls -l /etc/shadow
ls -l /bin/passwd
```

![8](Linux_5_pic/8.png)



### SGID

* SGID 主要实现如下两种功能：
* 让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）；
* 在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。

#### 属组权限

* SGID 的第一种功能是参考 SUID 设计的，不同点在于不仅获得文件所有者权限，还有属组权限。
* 与 SUID 类似，SGID 权限的最直接特征是权限表示法中**第二部分**（所属组的权限）的**最后一位**变成 **s** 或 **S**。
* 例如，在早期的 Linux 系统中，/dev/kmem 是一个字符设备文件（mem），用于存储内核程序要访问的数据，权限为：

```shell
ls -l /dev/kmem
```

![9](Linux_5_pic/9.png)

* 上述结果说明除了 root 和属于 system 组成员外，其他用户没有读取权限。
* 由于平时需要查看系统进程状态，为获取进程的状态信息，需要使用 ps 命令：
  * 下面查看 ps 命令文件上的 SGID 特殊权限位：

【】暂未知如何查看。

![10](Linux_5_pic/10.png)

* 正是因为 ps 命令被增加了 SGID 位因此执行时临时获取到了 system 用户组权限。

#### 自动继承用户组

* 下面介绍 SGID 的第二个作用。当创建或传送一个文件时，这个文件会自动归属于执行这个操作的用户。
* 当为一个共享目录中设置一个 SGID 权限位后，所有用户在里面创建的任何文件都会归属于该目录的所属组，而不再是自己的基本用户组。这就是 SGID 的第二个功能。
* 下面为举例：

```shell
cd /tmp
mkdir testdir
ls -ald testdir/
chmod -Rf 777 testdir/
chmod -Rf g+s testdir/
ls -ald testdir/
```

![11](Linux_5_pic/11.png)

* 上例先设置了目录的 777 权限（确保普通用户可以写入），并为该目录设置了 SGID 特殊权限位，这样切换到普通用户就能创建文件。而且该文件会继承新文件所在目录的所属组名称：

```shell
su - linuxprobe
cd /tmp/testdir/
echo "linuxprobe.com" > test
ls -al test
```

![12](Linux_5_pic/12.png)

#### 补充命令介绍：chmod

* chmod 命令用于设置文件或目录的权限。
* 格式：chmod [参数] 权限 文件或目录名称
* 权限可以用数字表示法，如 rwxrw----，写成数字是 760。

```shell
ls -al test
chmod 760 test
ls -l test
```

![13](Linux_5_pic/13.png)

#### 补充命令介绍：chown

* chown 命令用于设置文件或目录的所有者或所属组。
* 格式：chown [参数] 所有者:所属组 文件或目录名称
* 该命令和上述命令都可以在操作时加上大写参数 -R 来表示递归操作，这样对文件进行整体操作。

```shell
ls -l test
chown root:bin test
ls -l test
```

![14](Linux_5_pic/14.png)



### SBIT

* SBIT 特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。
* 换句话说，当对某个目录设置 SBIT 粘滞位（Sticky Bit）权限后，那么该目录中的文件就只能被其所有者执行删除操作。
* RHEL 7 系统中的 /tmp 就是一个共享文件目录，由于设置了 SBIT 特殊权限位，除非是该目录的所有者，否则无法执行删除操作。
* 和 SUID 和 SGID 类似，SBIT 权限会将权限表示位中**第三部分**的**最后一位**修改成 **t** 或 **T**。
* 下面是设置的例子：

```shell
su - linuxprobe
ls -ald /tmp
cd /tmp
ls -ald
echo "Welcome to linuxprobe.com" > test
chmod 777 test
ls -al test
```

![15](Linux_5_pic/15.png)

* 其实文件是否被删除并不取决于自身权限，而是所在目录是否有写入权限。
* 上述我们将 test 文件赋予 777 权限，但是由于 SBIT 的缘故，依然无法删除该文件：

```shell
su - blackshield
cd /tmp
rm -f test
```

![16](Linux_5_pic/16.png)

* 若需要对目录设置 SBIT 特殊权限位，只要用 chmod 命令即可。对应参数 o+t 代表设置 SBIT 粘滞位权限：

```shell
exit
cd ~
mkdir linux
cdmod -R o+t linux/
ls -ld linux/
```

![17](Linux_5_pic/17.png)





## 文件的隐藏属性

* Linux 系统中的文件除了具有一般权限和特殊权限，还具有**被隐藏起来的权限**，即默认情况不能被用户发觉。
* 隐藏属性会使得遇到明明权限充足却并无法删除某个文件，或者在日志文件中只能追加内容而不能删除内容。
  * 这在一定程度上阻止了黑客篡改系统日志的图谋。因此保障了系统的安全性。

### chattr 命令

* chattr 命令用于设置文件的隐藏权限。

#### 格式与用法

* chattr [参数] 文件
* 如果想把某个隐藏功能添加到文件上，需要在命令后面追加 "+参数"；
* 如果想把某个隐藏功能移出文件，则需要追加 "-参数"。

#### 参数

* chattr 命令中提供了非常丰富的参数如下：

| 参数 | 作用                                                         |
| :--- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若设置参数，仅能修改其中的子文件内容而不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）      |
| A    | 不再修改这个文件或目录的最后访问时间（atime）                |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用 dump 命令备份时忽略本文件/目录                          |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |

#### 例子

* 先创建一个普通文件，然后立即尝试删除：

```shell
echo "for Test" > linuxprobe
rm linuxprobe
```

![18](Linux_5_pic/18.png)

* 下面重新创建一个普通文件，设置不允许删除与覆盖（+a 参数）权限，然后再尝试将文件删除：

```shell
echo "for Test" > linuxprobe
chattr +a linuxprobe
rm linuxprobe
```

![19](Linux_5_pic/19.png)



### lsattr 命令

* lsattr 命令用于显示文件的隐藏权限。

#### 格式

* lsattr [参数] 文件

#### 例子

* 文件的隐藏权限必须使用 lsattr 命令来查看，而用 ls 命令看不出：
  * 我们使用 lsattr 命令查看隐藏权限，然后按照显示的隐藏类型将其去掉。最后删除。

```shell
ls -al linuxprobe
lsattr linuxprobe
chattr -a linuxprobe
lsattr linuxprobe
rm linuxprobe
```

![20](Linux_5_pic/20.png)





## 文件访问控制列表

* 一般权限、特殊权限、隐藏权限有一个共性——权限是针对某一类用户设置的。
* 如果希望对某个指定的用户进行单独的权限控制，需要用到文件的访问控制列表（ACL）。
* 基于普通文件或目录设置 ACL 就是针对**指定用户或用户组设置操作权限**。
* 当目录设置了 ACL，则目录中的文件会继承其 ACL；若针对文件设置了 ACL，则文件不再继承其所在目录的 ACL。

#### 引例

* 若切换到普通用户，然后尝试进入 root 管理员的家目录中，在没有针对普通用户对 root 管理员的家目录设置 ACL 之前，执行：

```shell
su - linuxprobe
cd /root
exit
```

![21](Linux_5_pic/21.png)



### setfacl 命令

* setfacl 命令用于管理文件的 ACL 规则。

#### 格式

* setfacl [参数] 文件名称
* setfacl 命令可以针对单一用户或用户组、单一文件或目录来进行读、写、执行权限的控制。
* 针对目录文件要使用 **-R** 递归参数；针对普通文件要使用 **-m** 参数；如果想删除某个文件的 ACL，则可以使用 **-b** 参数。

#### 例子

* 下面设置用户在 /root 目录上的权限：

```shell
setfacl -Rm u:linuxprobe:rwx /root
su - linuxprobe
cd /root
ls
cat anaconda-ks.cfg
```

![22](Linux_5_pic/22.png)

* 如何查看文件是否有 ACL 信息呢？常用的 ls 命令是看不到 ACL 表信息的，但若文件权限最后的点（.）变成了加号（+），这就意味着该文件已经设置 ACL 了。

```shell
ls -ld /root
```

![23](Linux_5_pic/23.png)



### getfacl 命令

* getfacl 命令用于**显示**文件上设置的 ACL 信息。

#### 格式

* getfacl 文件名称

#### 例子

* 下面使用 getfacl 命令显示在 root 管理员家目录设置 ACL 信息：

```shell
getfacl /root
```

![24](Linux_5_pic/24.png)





## su 命令与 sudo 服务

* 虽然实验环境中很少遇到安全问题，但在生产环境中要对安全多一份敬畏之心，不要用 root 做所有事情。



### su 命令

* su 命令可解决切换用户身份的需求，在当前用户不退出登录的情况下，顺畅切换到其他用户，如从 root 管理员切换到普通用户：

```shell
id
su - linuxprobe
id
```

![25](Linux_5_pic/25.png)



* （-）代表完全切换到新用户，把环境变量信息也变更为新用户的响应信息，而不是保留原始信息。
* 从 root 管理员切换到普通用户是不需要密码验证的，从普通用户切换成 root 管理员就需要密码验证，也是必要的安全检查：

```shell
su root
su - linuxprobe
exit
```

![26](Linux_5_pic/26.png)



### sudo 服务

* 虽然使用 su 命令可以使普通用户切换到 root 管理员身份来完成工作，但这会暴露 root 管理员密码，增大了系统密码被黑客获取的几率。
* sudo 命令可把指定命令的执行权限赋予给指定用户，这样既保证普通用户能够完成特定的工作，也可以避免泄露 root 管理员密码。
* 合理配置sudo服务，可兼顾系统的安全性和用户的便捷性。sudo服务的配置原则也很简单——在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。



### sudo 命令

* sudo 命令用于给普通用户提供额外的权限来完成 root 管理员的任务。

#### 格式

* sudo [参数] 命令名称

#### 参数

* sudo服务中可用的参数以及相应的作用如表：

| 参数             | 作用                                                   |
| ---------------- | ------------------------------------------------------ |
| -h               | 列出帮助信息                                           |
| -l               | 列出当前用户可执行的命令                               |
| -u 用户名或UID值 | 以指定的用户身份执行命令                               |
| -k               | 清空密码的有效时间，下次执行sudo时需要再次进行密码验证 |
| -b               | 在后台执行指定的命令                                   |
| -p               | 更改询问密码的提示语                                   |

#### 功能

* 总结来说，sudo命令具有如下功能：
  * 限制用户执行指定的命令：
  * 记录用户执行的每一条命令；
  * 配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数；
  * 验证密码的后5分钟内（默认值）无须再让用户再次验证密码。

#### visudo 命令

* 如果担心直接修改配置文件会出现问题，则可以使用 sudo 命令提供的 visudo 命令来配置用户权限。这条命令在配置用户权限时将禁止多个用户同时修改 sudoers 配置文件，还可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错。
* 只有 root 管理员才可以使用 visudo 命令编辑 sudo 服务的配置文件。
* 使用 visudo 命令配置 sudo 命令的配置文件时，其操作方法与 Vim 编辑器中用到的方法一致，因此在编写完成后记得在末行模式下保存并退出。在 sudo 命令的配置文件中，按照下面的格式将第 99 行（大约）填写上指定的信息：
* vim 添加权限的格式：**谁可以使用 允许使用的主机=（以谁的身份）可执行命令的列表**

```shell
visudo
# 输入：linuxprobe ALL=(ALL) ALL
```

![27](Linux_5_pic/27.png)

* 在填写完毕后记得要先保存再退出，然后切换至指定的普通用户身份，此时就可以用 sudo -l 命令查看到所有可执行的命令了（下面的命令中，验证的是该普通用户的密码，而不是 root 管理员的密码）

```shell
su - linuxprobe
sudo -l
```

![28](Linux_5_pic/28.png)

* 作为一名普通用户，是肯定不能看到root管理员的家目录（/root）中的文件信息的，但是，只需要在想执行的命令前面加上sudo命令就可以了：

```shell
ls /root
sudo ls /root
```

![29](Linux_5_pic/29.png)

* 但是考虑到生产环境中不允许某个普通用户拥有整个系统中所有命令的最高执行权（这也不符合前文提到的权限赋予原则，即尽可能少地赋予权限），因此 ALL 参数就有些不合适了。因此只能赋予普通用户具体的命令以满足工作需求，这也受到了必要的权限约束。
* 如果需要让某个用户只能使用 root 管理员的身份执行指定的命令，切记一定要给出该命令的绝对路径，否则系统会识别不出来。我们可以先使用 whereis 命令找出命令所对应的保存路径，然后把配置文件第 99 行的用户权限参数修改成对应的路径即可：

```shell
exit
whereis cat
visudo
# 输入：linuxprobe ALL=(ALL) /usr/bin/cat
```

![30](Linux_5_pic/30.png)

![31](Linux_5_pic/31.png)

* 在编辑好后依然是先保存再退出。再次切换到指定的普通用户，然后尝试正常查看某个文件的内容，此时系统提示没有权限。这时再使用 sudo 命令就可以顺利地查看文件内容了：

```shell
su - linuxprobe
cat /etc/shadow
sudo cat /etc/shadow
```

![32](Linux_5_pic/32.png)

* 在每次执行 sudo 命令后都会要求验证一下密码。虽然这个密码就是当前登录用户的密码，但是每次执行sudo命令都要输入一次密码其实也挺麻烦的，这时可以添加 NOPASSWD 参数，使得用户执行sudo命令时不再需要密码验证：

```shell
exit
whereis poweroff
visudo
# 输入：linuxprobe ALL=NOPASSWD: /usr/sbin/poweroff
```

![33](Linux_5_pic/33.png)

![34](Linux_5_pic/34.png)

* 当切换到普通用户后再执行命令时，就不用再频繁地验证密码了：

```shell
su - linuxprobe
poweroff
sudo poweroff
```

![35](Linux_5_pic/35.png)



* Written by：Sirius. Lu
* Reference：刘遄 《Linux 就该这么学》
* 2020.8.8

